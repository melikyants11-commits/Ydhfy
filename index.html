<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>The Isle: Mobile (Physics & Balance Fix)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; user-select: none; font-family: sans-serif; }
        
        #menu-layer { position: absolute; inset: 0; z-index: 300; background: #000; }
        #menu-canvas-container { width: 100%; height: 100%; }
        #menu-ui { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: flex-end; align-items: flex-start; padding: 20px; }
        
        .menu-logo { position: absolute; top: 30px; left: 30px; font-size: 32px; font-weight: 900; color: white; text-shadow: 2px 2px 0 #4caf50; letter-spacing: 2px; }
        
        #menu-coins { position: absolute; top: 30px; right: 30px; font-size: 24px; font-weight: bold; color: #ffeb3b; text-shadow: 1px 1px 0 #000; display: flex; align-items: center; gap: 5px; }
        
        .menu-buttons { position: absolute; bottom: 30px; left: 30px; display: flex; flex-direction: column; gap: 10px; pointer-events: auto; }
        .menu-btn { background: rgba(0, 0, 0, 0.7); border: 2px solid #555; color: #ddd; padding: 10px 30px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 2px; text-align: left; width: 180px; border-radius: 4px; }
        .menu-btn:active { border-color: #4caf50; color: white; background: rgba(76, 175, 80, 0.4); transform: scale(0.98); }
        
        #char-select { position: absolute; top: 0; right: 0; bottom: 0; width: 200px; background: rgba(0,0,0,0.9); border-left: 1px solid #333; display: none; flex-direction: column; padding: 15px; pointer-events: auto; z-index: 350; backdrop-filter: blur(10px); }
        .select-header { color: #888; font-size: 10px; letter-spacing: 1px; margin-bottom: 10px; text-align: center; }
        .dino-list { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; padding-right: 2px; }
        .dino-card { position: relative; width: 100%; height: 50px; background: rgba(255,255,255,0.05); border: 1px solid #444; border-radius: 4px; display: flex; align-items: center; justify-content: flex-start; padding: 0 10px; gap: 10px; cursor: pointer; transition: all 0.2s; flex-shrink: 0; }
        .dino-card.selected { border-color: #4caf50; background: rgba(76, 175, 80, 0.2); }
        .card-info { display: flex; flex-direction: column; }
        .dino-name { font-weight: bold; font-size: 11px; color: white; }
        .dino-desc { font-size: 8px; color: #aaa; margin-top: 1px; }
        .dino-icon { font-size: 18px; }
        .lock-icon { position: absolute; right: 10px; font-size: 14px; color: #ff5252; display: none; }
        
        #btnConfirm { margin-top: 10px; width: 100%; height: 40px; background: #4caf50; border: none; color: white; font-size: 12px; font-weight: bold; cursor: pointer; border-radius: 4px; letter-spacing: 1px; display: flex; justify-content: center; align-items: center; }
        #btnConfirm.buy-mode { background: #ff9800; }
        #btnConfirm.buy-mode:active { background: #e65100; }
        #btnBack { margin-top: 5px; width: 100%; height: 30px; background: transparent; border: 1px solid #555; color: #888; font-size: 10px; font-weight: bold; cursor: pointer; border-radius: 4px; }

        #game-layer { position: absolute; inset: 0; display: none; }
        #game-canvas-container { width: 100%; height: 100%; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 100; }
        
        #game-coins { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); color: #ffeb3b; font-weight: bold; font-size: 18px; text-shadow: 1px 1px 0 #000; z-index: 200; display: flex; gap: 5px; }

        #zone-left { position: absolute; top: 0; left: 0; width: 40%; height: 100%; pointer-events: auto; z-index: 10; }
        #zone-right { position: absolute; top: 0; right: 0; width: 60%; height: 100%; pointer-events: auto; z-index: 10; }
        #joyBase { position: absolute; width: 70px; height: 70px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.1); display: none; z-index: 15; pointer-events: none; }
        #joyStick { position: absolute; top: 50%; left: 50%; width: 30px; height: 30px; border-radius: 50%; background: rgba(255,255,255,0.3); transform: translate(-50%, -50%); }

        #btnSettings { position: absolute; top: 15px; right: 15px; width: 30px; height: 30px; background: rgba(0,0,0,0.6); border: 1px solid #777; color: #ccc; font-size: 18px; display: flex; justify-content: center; align-items: center; pointer-events: auto; cursor: pointer; border-radius: 4px; z-index: 400; }
        #settingsPanel { position: absolute; top: 50px; right: 15px; width: 150px; background: rgba(20,20,20,0.95); border: 1px solid #444; padding: 10px; display: none; pointer-events: auto; z-index: 400; }
        .setting-group { margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .setting-label { color: #888; font-size: 10px; margin-bottom: 5px; letter-spacing: 1px; font-weight: bold; }
        .btn-row { display: flex; justify-content: space-between; }
        .res-btn { width: 32%; height: 25px; background: #222; border: 1px solid #444; color: #888; font-size: 10px; cursor: pointer; border-radius: 2px; }
        .res-btn.active { background: #4caf50; color: white; border-color: #4caf50; }
        .exit-btn { width: 100%; height: 30px; background: #c62828; color: white; border: none; margin-top: 5px; font-weight: bold; cursor: pointer; }

        #legacy-hud { position: absolute; bottom: 15px; right: 15px; display: flex; align-items: flex-end; gap: 5px; pointer-events: none; z-index: 20; }
        .hud-stat { position: relative; background: rgba(0,0,0,0.6); mask-size: contain; mask-repeat: no-repeat; mask-position: bottom; -webkit-mask-size: contain; -webkit-mask-repeat: no-repeat; -webkit-mask-position: bottom; width: 40px; height: 40px; border-radius: 50%; border: 1px solid #555; overflow: hidden; }
        .stat-fill { position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; transition: height 0.2s linear; }
        
        .icon-thirst { -webkit-mask-image: url('https://raw.githubusercontent.com/melikyants11-commits/Theisl/11ebccb2c4d90341df2bbe742f530eec274aa31e/drink.png'); mask-image: url('https://raw.githubusercontent.com/melikyants11-commits/Theisl/11ebccb2c4d90341df2bbe742f530eec274aa31e/drink.png'); } 
        .icon-thirst .stat-fill { background: #2196f3; }
        .icon-stamina { -webkit-mask-image: url('https://raw.githubusercontent.com/melikyants11-commits/Theisl/11ebccb2c4d90341df2bbe742f530eec274aa31e/stamina.png'); mask-image: url('https://raw.githubusercontent.com/melikyants11-commits/Theisl/11ebccb2c4d90341df2bbe742f530eec274aa31e/stamina.png'); } 
        .icon-stamina .stat-fill { background: #ff9800; }
        .icon-hunger { -webkit-mask-image: url('https://raw.githubusercontent.com/melikyants11-commits/Theisl/11ebccb2c4d90341df2bbe742f530eec274aa31e/eat.png'); mask-image: url('https://raw.githubusercontent.com/melikyants11-commits/Theisl/11ebccb2c4d90341df2bbe742f530eec274aa31e/eat.png'); } 
        .icon-hunger .stat-fill { background: #4caf50; }

        #actions { position: absolute; bottom: 70px; right: 15px; display: flex; gap: 6px; pointer-events: auto; z-index: 100; }
        .btn { width: 28px; height: 28px; border-radius: 50%; background: rgba(0,0,0,0.6); border: 2px solid rgba(255,255,255,0.3); color: white; display: flex; justify-content: center; align-items: center; font-size: 14px; cursor: pointer; backdrop-filter: blur(2px); transition: all 0.1s; padding: 0; margin: 0; line-height: 1; }
        .btn:active { transform: scale(0.9); }
        .btn.active-mode { border-color: #ff9800; color: #ff9800; background: rgba(255, 152, 0, 0.2); }
        .btn.cooldown { opacity: 0.3; pointer-events: none; border-color: #555; }
        #btnEatAction { border-color: #4caf50; color: #4caf50; background: rgba(76,175,80,0.2); display: none; animation: popIn 0.3s ease; }
        #btnDrinkAction { border-color: #2196f3; color: #2196f3; background: rgba(33,150,243,0.2); display: none; animation: popIn 0.3s ease; }
        @keyframes popIn { from { transform: scale(0); } to { transform: scale(1); } }
        
        .damage-text { position: absolute; font-weight: bold; font-size: 24px; text-shadow: 1px 1px 0 #000; pointer-events: none; animation: floatUp 1s forwards; z-index: 150; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-40px); opacity: 0; } }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 12px; letter-spacing: 2px; z-index: 400; display: block;}

        #hp-bars-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 90; }
        .bot-hp-bar { position: absolute; width: 30px; height: 4px; background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.3); border-radius: 1px; transform: translate(-50%, -50%); }
        .bot-hp-fill { height: 100%; background: #d32f2f; width: 100%; transition: width 0.2s; }

        #player-hp-bar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 120px; height: 8px; background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 4px; overflow: hidden; pointer-events: none; z-index: 25; }
        #player-hp-fill { width: 100%; height: 100%; background: #43a047; transition: width 0.2s; }

        #minimap { position: absolute; top: 15px; left: 15px; width: 60px; height: 60px; background: rgba(0,0,0,0.5); border: 2px solid #555; border-radius: 50%; overflow: hidden; z-index: 200; backdrop-filter: blur(2px); }
        #mm-player { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: #4caf50; border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 4px #4caf50; }
        .mm-dot { position: absolute; width: 3px; height: 3px; background: #f44336; border-radius: 50%; transform: translate(-50%, -50%); }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="menu-layer">
        <div id="menu-canvas-container" style="position: absolute; inset:0;"></div>
        <div id="menu-coins">üí∞ 0</div>
        <div id="menu-ui">
            <div class="menu-logo">THE ISLE: MOBILE</div>
            <div class="menu-buttons" id="mainButtons">
                <button class="menu-btn" onclick="window.openSelector()">PLAY</button>
                <button class="menu-btn" onclick="window.exitToMenu()">EXIT GAME</button>
            </div>
            <div id="char-select">
                <div class="select-header">SELECT DINOSAUR</div>
                <div class="dino-list">
                    <div class="dino-card selected" onclick="window.previewDino('raptor')" id="card-raptor">
                        <div class="dino-icon">ü¶ñ</div><div class="card-info"><div class="dino-name">Velociraptor</div><div class="dino-desc">Fast Carnivore</div></div>
                        <div class="lock-icon" id="lock-raptor">üîí</div>
                    </div>
                    <div class="dino-card" onclick="window.previewDino('trike')" id="card-trike">
                        <div class="dino-icon">ü¶ï</div><div class="card-info"><div class="dino-name">Triceratops</div><div class="dino-desc">Heavy Herbivore</div></div>
                        <div class="lock-icon" id="lock-trike">üîí</div>
                    </div>
                </div>
                <button id="btnConfirm" onclick="window.tryStartGame()">START</button>
                <button id="btnBack" onclick="window.closeSelector()">CANCEL</button>
            </div>
        </div>
    </div>

    <div id="game-layer">
        <div id="game-canvas-container"></div>
        <div id="game-coins">üí∞ 0</div>
        <div id="hp-bars-container"></div>
        <div id="player-hp-bar"><div id="player-hp-fill"></div></div>
        
        <div id="minimap"><div id="mm-player"></div></div>

        <div id="ui-layer">
            <div id="btnSettings">‚öôÔ∏è</div>
            <div id="settingsPanel">
                <div class="setting-group"><div class="setting-label">VEGETATION</div>
                    <div class="btn-row" id="grassRow"><button class="res-btn" id="btnVegLow">OFF</button><button class="res-btn active" id="btnVegMid">ON</button></div>
                </div>
                <div class="setting-group"><div class="setting-label">RENDER SCALE</div>
                    <div class="btn-row" id="resRow"><button class="res-btn" id="btnResLow">20%</button><button class="res-btn active" id="btnResMid">55%</button><button class="res-btn" id="btnResHigh">100%</button></div>
                </div>
                <button class="exit-btn" onclick="window.exitToMenu()">EXIT</button>
            </div>
            <div id="zone-left"></div><div id="zone-right"></div>
            <div id="joyBase"><div id="joyStick"></div></div>
            <div id="legacy-hud">
                <div class="hud-stat icon-thirst"><div class="stat-fill" id="fill-thirst"></div></div>
                <div class="hud-stat icon-stamina"><div class="stat-fill" id="fill-stamina"></div></div>
                <div class="hud-stat icon-hunger"><div class="stat-fill" id="fill-hunger"></div></div>
            </div>
            <div id="actions">
                <div class="btn" id="btnDrinkAction">üíß</div>
                <div class="btn" id="btnEatAction">üçΩÔ∏è</div>
                <div class="btn" id="btnBite">‚öîÔ∏è</div>
                <div class="btn" id="btnRoar">üì¢</div>
                <div class="btn" id="btnRun">‚ö°</div>
                <div class="btn" id="btnRest">üí§</div>
            </div>
        </div>
    </div>
    <div id="loading">LOADING ENGINE...</div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const SAVE_KEY = 'TheIsleMobile_Save_v1';
        let playerData = { coins: 0, unlocked: ['raptor'] };

        function loadData() {
            const raw = localStorage.getItem(SAVE_KEY);
            if(raw) {
                try { playerData = JSON.parse(raw); } catch(e){ console.error("Save Error", e); }
            }
            if(!playerData.unlocked) playerData.unlocked = ['raptor'];
            if(!playerData.coins) playerData.coins = 0;
            updateCoinUI();
        }

        function saveData() {
            localStorage.setItem(SAVE_KEY, JSON.stringify(playerData));
            updateCoinUI();
        }

        function updateCoinUI() {
            document.getElementById('menu-coins').innerText = `üí∞ ${playerData.coins}`;
            document.getElementById('game-coins').innerText = `üí∞ ${playerData.coins}`;
            document.getElementById('lock-raptor').style.display = playerData.unlocked.includes('raptor') ? 'none' : 'block';
            document.getElementById('lock-trike').style.display = playerData.unlocked.includes('trike') ? 'none' : 'block';
        }

        class SimplexNoise {
            constructor() { this.p=new Uint8Array(512); for(let i=0;i<256;i++)this.p[i]=this.p[i+256]=Math.floor(Math.random()*256); }
            fade(t){return t*t*t*(t*(t*6-15)+10);} lerp(t,a,b){return a+t*(b-a);}
            grad(hash,x,y){const h=hash&15,u=h<8?x:y,v=h<4?y:h===12||h===14?x:0;return((h&1)===0?u:-u)+((h&2)===0?v:-v);}
            noise2D(x,y){
                const X=Math.floor(x)&255,Y=Math.floor(y)&255;x-=Math.floor(x);y-=Math.floor(y);
                const u=this.fade(x),v=this.fade(y);
                const A=this.p[X]+Y,B=this.p[X+1]+Y;
                return this.lerp(v,this.lerp(u,this.grad(this.p[A],x,y),this.grad(this.p[B],x-1,y)),this.lerp(u,this.grad(this.p[A+1],x,y-1),this.grad(this.p[B+1],x-1,y-1)));
            }
        }

        const CONFIG = {
            raptor: { 
                price: 0,
                model: 'https://raw.githubusercontent.com/melikyants11-commits/Theislemobile/main/velotheisle.glb', 
                diet: 'carnivore', 
                speedWalk: 0.040, // LOWERED SPEED
                speedRun: 0.12, 
                staminaDrain: 4, // LOWERED DRAIN (MORE STAMINA)
                animIdle: 'idle_v2', animBiteScale: 1.0, 
                camY: 0.5, camDist: 6, scale: 1.0,
                modelOffsetY: 0.2, // LIFT MODEL UP
                maxHp: 50, damage: 10,
                attackCooldown: 1.2, // INCREASED FOR BOT
                playerAttackCooldown: 0.7,
                attackRange: 4.5,
                sndRoar: 'https://raw.githubusercontent.com/melikyants11-commits/Theislemobil-/main/AudioCutter_VID_20250602_172624_149_02062025(2).mp3',
                sndBite: 'https://raw.githubusercontent.com/melikyants11-commits/Theislemobil-/main/AudioCutter_VID_20250602_172624_149_02062025.mp3'
            },
            trike: { 
                price: 5000,
                model: 'https://raw.githubusercontent.com/melikyants11-commits/Theisl/11ebccb2c4d90341df2bbe742f530eec274aa31e/dino.glb', 
                diet: 'herbivore', 
                speedWalk: 0.040, 
                speedRun: 0.08, 
                staminaDrain: 8,
                animIdle: 'idle', 
                animBiteScale: 4.0, 
                fixedRoarDuration: 5.0,
                camY: 1.5, camDist: 14, scale: 1.0, 
                modelOffsetY: 0.0,
                maxHp: 200, damage: 60,
                attackCooldown: 3.0, 
                playerAttackCooldown: 2.0, 
                attackRange: 7.0,
                sndRoar: 'https://raw.githubusercontent.com/melikyants11-commits/Theislemobil-/main/dinosaur-munch_fkzz2reu.mp3'
            }
        };
        let selectedDino = 'raptor'; let activeConfig = null; let isGameRunning = false;
        let renderer, menuScene, menuCamera, gameScene, gameCamera;
        let menuMixer, gameMixer, bots = [];
        let clock = new THREE.Clock(); let simplex = new SimplexNoise();
        let playerDino = null, grassMesh = null, treesMesh = null, waterMesh = null;
        let treePositions = [];
        let player = { hp: 100, maxHp: 100, hunger: 100, thirst: 100, stamina: 100, resting: false, running: false, actionState: 'idle', moving: false, cdBite: false, cdRoar: false };
        let input = { x: 0, y: 0 }; let camAngle = Math.PI, camHeight = 0.5; let neckBone = null;
        const actions = { idle: null, walk: null, run: null, rest: null, roar: null, bite: null, eat: null, drink: null };
        const WATER_LEVEL = -1.5, GRASS_MAX = 25000, TREES_MAX = 20; let renderScale = 0.55;
        const BOTS_TO_SPAWN = ['trike', 'raptor', 'raptor'];
        let menuDinoTargetX = 1.2;

        initCommon(); initMenu(); animate();

        function initCommon() {
            loadData(); 
            document.getElementById('loading').style.display = 'none';
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio * renderScale);
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.BasicShadowMap;
        }

        function initMenu() {
            document.getElementById('menu-canvas-container').appendChild(renderer.domElement);
            menuScene = new THREE.Scene(); menuScene.background = new THREE.Color(0x111111);
            menuCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            menuCamera.position.set(3, 1.5, 6); menuCamera.lookAt(0, 0.8, 0);
            const light = new THREE.DirectionalLight(0xffffff, 2); light.position.set(5, 10, 5); menuScene.add(light); 
            menuScene.add(new THREE.AmbientLight(0xffffff, 3.0)); 
            loadMenuDino(CONFIG[selectedDino].model, CONFIG[selectedDino].animIdle, CONFIG[selectedDino].scale);
        }

        function preloadSounds() {
            ['raptor', 'trike'].forEach(type => {
                const cfg = CONFIG[type];
                if(cfg.sndRoar) { cfg.audioRoar = new Audio(cfg.sndRoar); cfg.audioRoar.preload = 'auto'; cfg.audioRoar.volume = 1.0; }
                if(cfg.sndBite) { cfg.audioBite = new Audio(cfg.sndBite); cfg.audioBite.preload = 'auto'; cfg.audioBite.volume = 1.0; }
            });
        }

        function applySkin(scene, textureUrl) {
            const tl = new THREE.TextureLoader();
            const tex = tl.load(textureUrl);
            tex.flipY = false; tex.colorSpace = THREE.SRGBColorSpace;
            scene.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.castShadow = true; child.material.metalness = 0.0; child.material.roughness = 1.0; child.material.emissive = new THREE.Color(0x000000); 
                    child.material.map = tex; child.material.needsUpdate = true;
                }
            });
        }

        function fixMaterials(scene) {
            scene.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.castShadow = true; child.material.metalness = 0.0; child.material.roughness = 1.0; child.material.emissive = new THREE.Color(0x000000); 
                    if(child.material.map) { child.material.map.colorSpace = THREE.SRGBColorSpace; }
                }
            });
        }

        function loadMenuDino(modelPath, idleName, scale) {
            if(menuScene.userData.dino) menuScene.remove(menuScene.userData.dino);
            const loader = new GLTFLoader();
            loader.load(modelPath, (gltf) => {
                const dino = gltf.scene;
                dino.scale.setScalar(scale * 0.7);
                dino.position.set(menuDinoTargetX, -0.4, 0);
                if (selectedDino === 'trike') applySkin(dino, 'https://raw.githubusercontent.com/melikyants11-commits/Theislemobidd/main/trike.png');
                else fixMaterials(dino);
                menuScene.add(dino); menuScene.userData.dino = dino;
                menuMixer = new THREE.AnimationMixer(dino);
                const clip = gltf.animations.find(c => c.name.toLowerCase().includes(idleName)) || gltf.animations[0];
                if(clip) menuMixer.clipAction(clip).play();
            });
        }

        window.openSelector = function() { 
            document.getElementById('mainButtons').style.display = 'none'; 
            document.getElementById('char-select').style.display = 'flex'; 
            menuDinoTargetX = -1.2; 
            window.previewDino(selectedDino); 
        };
        window.closeSelector = function() { document.getElementById('char-select').style.display = 'none'; document.getElementById('mainButtons').style.display = 'flex'; menuDinoTargetX = 1.2; };
        
        window.previewDino = function(type) {
            selectedDino = type; 
            document.querySelectorAll('.dino-card').forEach(c => c.classList.remove('selected')); 
            document.getElementById('card-' + type).classList.add('selected');
            const cfg = CONFIG[type]; 
            loadMenuDino(cfg.model, cfg.animIdle, cfg.scale);
            
            const btn = document.getElementById('btnConfirm');
            if(playerData.unlocked.includes(type)) {
                btn.innerText = "START";
                btn.classList.remove('buy-mode');
                btn.style.background = "#4caf50";
            } else {
                btn.innerText = `BUY (${cfg.price})`;
                btn.classList.add('buy-mode');
                if(playerData.coins >= cfg.price) btn.style.background = "#ff9800";
                else btn.style.background = "#555";
            }
        };

        window.tryStartGame = function() {
            if(playerData.unlocked.includes(selectedDino)) { window.startGame(); } else {
                const cost = CONFIG[selectedDino].price;
                if(playerData.coins >= cost) {
                    playerData.coins -= cost; playerData.unlocked.push(selectedDino); saveData(); window.previewDino(selectedDino);
                } else { alert("Not enough coins!"); }
            }
        };

        window.startGame = function() { document.getElementById('menu-layer').style.display = 'none'; document.getElementById('game-layer').style.display = 'block'; document.getElementById('loading').style.display = 'block'; document.getElementById('loading').innerText="LOADING WORLD..."; isGameRunning = true; initGameWorld(); };
        window.exitToMenu = function() { location.reload(); };

        window.setResolution = function(scale, btn) { renderScale = scale; document.querySelectorAll('#resRow .res-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); renderer.setPixelRatio(window.devicePixelRatio * renderScale); };
        window.setVegetation = function(level, btn) { document.querySelectorAll('#grassRow .res-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); let g = 0, t = 0; if (level === 'mid') { g = GRASS_MAX; t = TREES_MAX; } if(grassMesh) grassMesh.count = g; if(treesMesh) treesMesh.count = t; };

        function initGameWorld() {
            activeConfig = CONFIG[selectedDino]; player.hp = activeConfig.maxHp; player.maxHp = activeConfig.maxHp;
            document.getElementById('game-canvas-container').appendChild(renderer.domElement);
            gameScene = new THREE.Scene(); gameScene.background = new THREE.Color(0x88aaee); gameScene.fog = new THREE.Fog(0x88aaee, 20, 300);
            gameCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 300);
            gameCamera.position.set(0, 30, 30); gameCamera.lookAt(0, 0, 0);
            gameScene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 1.0)); 
            gameScene.add(new THREE.AmbientLight(0xffffff, 1.5)); 
            const sun = new THREE.DirectionalLight(0xffeebb, 1.5); sun.position.set(50, 100, 50); sun.castShadow = true; gameScene.add(sun);
            preloadSounds(); createLandscape(); loadGameAssets(); setupControls();
        }

        function getH(x, z) {
            let y = simplex.noise2D(x * 0.015, z * 0.015) * 4;
            if (y < -1.0) { y = -1.0 - (Math.abs(y + 1.0) * 1.5); } 
            const dist = Math.sqrt(x*x + z*z); if (dist > 100) y -= (dist - 100) * 0.2; y += 25 * Math.exp(-0.0015 * (dist * dist)); 
            return y;
        }

        function findPlainsSpawn() {
            let x, z, y, tries = 0;
            do { x = (Math.random()-0.5) * 150; z = (Math.random()-0.5) * 150; y = getH(x,z); tries++; } while((y < WATER_LEVEL + 1.0 || y > 5.0) && tries < 200);
            return new THREE.Vector3(x || 30, y || 0, z || 30);
        }

        function createLandscape() {
            const texLoader = new THREE.TextureLoader();
            const groundTex = texLoader.load('https://raw.githubusercontent.com/melikyants11-commits/Theislemobile/main/ground.jpg'); groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping; groundTex.repeat.set(20, 20);
            const geo = new THREE.PlaneGeometry(400, 400, 40, 40); geo.rotateX(-Math.PI/2);
            const pos = geo.attributes.position; for(let i=0; i<pos.count; i++) pos.setY(i, getH(pos.getX(i), pos.getZ(i))); geo.computeVertexNormals();
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({map: groundTex, roughness:1, color:0x888888})); mesh.receiveShadow = true; gameScene.add(mesh);
            const waterTex = texLoader.load('https://raw.githubusercontent.com/melikyants11-commits/Theisl/11ebccb2c4d90341df2bbe742f530eec274aa31e/vater.jpg'); waterTex.wrapS = waterTex.wrapT = THREE.RepeatWrapping; waterTex.repeat.set(20, 20);
            const water = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000).rotateX(-Math.PI/2), new THREE.MeshStandardMaterial({map:waterTex, color:0x4fc3f7, transparent:true, opacity:0.75, roughness:0.1}));
            water.position.y = WATER_LEVEL; gameScene.add(water); waterMesh = water;
            generateVegetation(texLoader);
        }

        function generateVegetation(loader) {
            const gt = loader.load('https://raw.githubusercontent.com/melikyants11-commits/Theisl/11ebccb2c4d90341df2bbe742f530eec274aa31e/grass.png');
            grassMesh = new THREE.InstancedMesh(new THREE.PlaneGeometry(1,1).translate(0,0.5,0), new THREE.MeshStandardMaterial({map:gt, alphaTest:0.5, side:2, transparent:true}), GRASS_MAX); grassMesh.count = GRASS_MAX; grassMesh.castShadow = false;
            const dum = new THREE.Object3D(); const col = new THREE.Color();
            for(let i=0; i<GRASS_MAX; i++) {
                let x=(Math.random()-0.5)*300, z=(Math.random()-0.5)*300, y=getH(x,z);
                if(y > WATER_LEVEL+0.2) { dum.position.set(x,y,z); dum.scale.setScalar(0.8+Math.random()); dum.rotation.y=Math.random()*3; dum.updateMatrix(); grassMesh.setMatrixAt(i, dum.matrix); grassMesh.setColorAt(i, col.setHex(0xdddddd)); }
                else { dum.position.set(0,-1000,0); dum.updateMatrix(); grassMesh.setMatrixAt(i, dum.matrix); }
            }
            grassMesh.instanceColor.needsUpdate = true; grassMesh.instanceMatrix.needsUpdate = true; gameScene.add(grassMesh);
            const gltfl = new GLTFLoader();
            gltfl.load('https://raw.githubusercontent.com/melikyants11-commits/Theislemobidd/main/tree_low-poly.glb', (g) => {
                let tm, tg; g.scene.traverse(o=>{if(o.isMesh){tm=o.material; tg=o.geometry; o.castShadow=true;}});
                if(tg){
                    treesMesh = new THREE.InstancedMesh(tg, tm, TREES_MAX); treesMesh.castShadow=true; treesMesh.receiveShadow=true; treesMesh.count=TREES_MAX;
                    for(let i=0; i<TREES_MAX; i++){
                        let pos = findPlainsSpawn(); dum.position.copy(pos); dum.scale.setScalar(0.3 + Math.random()*0.2); dum.rotation.y=Math.random()*3; dum.updateMatrix(); treesMesh.setMatrixAt(i, dum.matrix); treePositions.push(pos.clone());
                    }
                    treesMesh.instanceMatrix.needsUpdate = true; gameScene.add(treesMesh);
                }
            }, undefined, function(e){ console.log("Trees skipped"); });
        }

        function cleanLegsFromClip(clip) {
            if(!clip) return;
            const LEG_BONES = ['thigh', 'calf', 'leg', 'foot', 'toe', 'hip', 'pelvis', 'root', 'master'];
            clip.tracks = clip.tracks.filter(track => !LEG_BONES.some(bone => track.name.toLowerCase().includes(bone)));
        }

        function createHpBar() {
            const bar = document.createElement('div'); bar.className = 'bot-hp-bar';
            const fill = document.createElement('div'); fill.className = 'bot-hp-fill'; bar.appendChild(fill);
            document.getElementById('hp-bars-container').appendChild(bar); return { bar, fill };
        }

        function createMiniMapDot() {
            const dot = document.createElement('div'); dot.className = 'mm-dot';
            document.getElementById('minimap').appendChild(dot); return dot;
        }

        function loadGameAssets() {
            const loader = new GLTFLoader();
            let assetsLoaded = 0; const totalAssets = 1 + BOTS_TO_SPAWN.length; 
            const checkLoaded = () => { assetsLoaded++; if (assetsLoaded === totalAssets) document.getElementById('loading').style.display = 'none'; };

            loader.load(activeConfig.model, (gltf) => {
                playerDino = gltf.scene; 
                playerDino.scale.setScalar(activeConfig.scale); 
                playerDino.position.copy(findPlainsSpawn());
                
                playerDino.traverse(o => { if(o.isBone && (o.name.includes('Neck')||o.name.includes('Cervical'))) neckBone=o; });
                
                if(selectedDino === 'trike') applySkin(playerDino, 'https://raw.githubusercontent.com/melikyants11-commits/Theislemobidd/main/trike.png');
                else fixMaterials(playerDino);

                gameScene.add(playerDino);
                gameMixer = new THREE.AnimationMixer(playerDino);
                setupAnimations(gameMixer, gltf.animations, activeConfig, actions);
                checkLoaded();
            });

            BOTS_TO_SPAWN.forEach(type => {
                const cfg = CONFIG[type];
                loader.load(cfg.model, (gltf) => {
                    const bot = gltf.scene; bot.scale.setScalar(cfg.scale);
                    const bSpawn = findPlainsSpawn(); bSpawn.x += (Math.random()-0.5)*30; 
                    bot.position.copy(bSpawn); bot.traverse(o => { if(o.isMesh) o.castShadow=true; });
                    
                    if(type === 'trike') applySkin(bot, 'https://raw.githubusercontent.com/melikyants11-commits/Theislemobidd/main/trike.png');
                    else fixMaterials(bot);

                    gameScene.add(bot);
                    const bMixer = new THREE.AnimationMixer(bot);
                    const bActs = {}; setupAnimations(bMixer, gltf.animations, cfg, bActs);
                    
                    const hpUI = createHpBar();
                    const mmDot = createMiniMapDot();
                    
                    bots.push({ 
                        mesh: bot, mixer: bMixer, acts: bActs, 
                        hp: cfg.maxHp, maxHp: cfg.maxHp, damage: cfg.damage, 
                        dead: false, state: 'patrol', target: new THREE.Vector3(), 
                        stuck: 0, type: type, attackCooldown: 0, 
                        hpUI: hpUI, mmDot: mmDot, deathTimer: 0 
                    });
                    pickBotTarget(bots[bots.length-1]);
                    checkLoaded();
                });
            });
        }

        function setupAnimations(mixer, clips, cfg, acts) {
            const find = n => clips.find(c => c.name.toLowerCase().includes(n));
            const idle = find(cfg.animIdle) || find('idle') || clips[0], walk = find('walk'), run = find('run'), bite = find('bite') || find('attack'), eat = find('eat_v2') || find('eat'), drink = find('drink_v2') || find('drink'), rest = find('sit_idle') || find('rest') || idle, roar = find('broadcast') || find('roar');
            
            if(bite) cleanLegsFromClip(bite); 
            if(roar) cleanLegsFromClip(roar);

            acts.idle = mixer.clipAction(idle); if(walk) acts.walk = mixer.clipAction(walk); if(run) acts.run = mixer.clipAction(run); if(rest) acts.rest = mixer.clipAction(rest);
            if(bite) { 
                acts.bite = mixer.clipAction(bite); 
                acts.bite.timeScale = cfg.animBiteScale || 1.5; 
                acts.bite.loop = THREE.LoopOnce; acts.bite.layer = 1; acts.bite.clampWhenFinished = true; 
            }
            if(roar) { 
                acts.roar = mixer.clipAction(roar); 
                if (cfg.fixedRoarDuration) {
                    acts.roar.timeScale = roar.duration / cfg.fixedRoarDuration;
                } else {
                    acts.roar.timeScale = cfg.animRoarScale || 1.0; 
                }
                acts.roar.loop = THREE.LoopOnce; acts.roar.layer = 1; acts.roar.clampWhenFinished = true; 
            }
            if(eat) { acts.eat = mixer.clipAction(eat); acts.eat.loop = THREE.LoopOnce; acts.eat.layer = 2; }
            if(drink) { acts.drink = mixer.clipAction(drink); acts.drink.loop = THREE.LoopOnce; acts.drink.layer = 2; }
            for(let k in acts) if(acts[k]) { acts[k].play(); acts[k].weight = 0; }
            if(acts.idle) acts.idle.weight = 1;
        }

        function pickBotTarget(bot) {
            const ang = Math.random() * 6.28; const rad = 20 + Math.random() * 50;
            const tx = bot.mesh.position.x + Math.cos(ang)*rad; const tz = bot.mesh.position.z + Math.sin(ang)*rad; const ty = getH(tx, tz);
            if ((bot.type === 'trike' || bot.type === 'raptor') && ty < WATER_LEVEL + 0.5) { pickBotTarget(bot); return; }
            bot.target.set(tx, ty, tz); bot.state = 'patrol'; bot.stuck = 0;
        }

        function updateGameBots(dt) {
            const tempV = new THREE.Vector3();
            
            bots.forEach(b => {
                if (b.dead) {
                    // CORPSE POSITION FIX
                    b.mesh.position.y = getH(b.mesh.position.x, b.mesh.position.z);
                    
                    b.deathTimer += dt;
                    if (b.deathTimer > 30) {
                        b.dead = false;
                        b.hp = b.maxHp;
                        b.deathTimer = 0;
                        b.mesh.rotation.z = 0;
                        const newPos = findPlainsSpawn();
                        newPos.x += (Math.random()-0.5)*100; 
                        newPos.z += (Math.random()-0.5)*100;
                        b.mesh.position.copy(newPos);
                        b.mesh.position.y = getH(newPos.x, newPos.z);
                        pickBotTarget(b);
                        
                        b.mixer.stopAllAction();
                        if(b.acts.idle) { b.acts.idle.reset(); b.acts.idle.play(); b.acts.idle.setEffectiveWeight(1); }
                        if(b.acts.walk) { b.acts.walk.reset(); b.acts.walk.play(); b.acts.walk.setEffectiveWeight(0); }
                        if(b.acts.run) { b.acts.run.reset(); b.acts.run.play(); b.acts.run.setEffectiveWeight(0); }
                    }
                }

                if (b.mmDot && playerDino) {
                    if (b.dead) {
                        b.mmDot.style.display = 'none';
                    } else {
                        b.mmDot.style.display = 'block';
                        const dx = b.mesh.position.x - playerDino.position.x;
                        const dz = b.mesh.position.z - playerDino.position.z;
                        let mx = dx / 2; let my = dz / 2;
                        const dist = Math.sqrt(mx*mx + my*my);
                        if (dist > 30) { const angle = Math.atan2(my, mx); mx = Math.cos(angle) * 30; my = Math.sin(angle) * 30; }
                        b.mmDot.style.left = (30 + mx) + 'px';
                        b.mmDot.style.top = (30 + my) + 'px';
                    }
                }

                const dist = b.mesh.position.distanceTo(playerDino.position);

                if (b.hpUI) {
                    if (b.dead || dist > 30) { 
                        b.hpUI.bar.style.display = 'none';
                    } else {
                        tempV.copy(b.mesh.position);
                        tempV.y += 2.0; 
                        tempV.project(gameCamera);
                        const x = (tempV.x * .5 + .5) * window.innerWidth;
                        const y = (-(tempV.y * .5) + .5) * window.innerHeight;
                        
                        if (tempV.z > 1) {
                            b.hpUI.bar.style.display = 'none';
                        } else {
                            b.hpUI.bar.style.display = 'block';
                            b.hpUI.bar.style.left = x + 'px';
                            b.hpUI.bar.style.top = y + 'px';
                            b.hpUI.fill.style.width = (b.hp / b.maxHp * 100) + '%';
                        }
                    }
                }

                if(b.dead) return;
                
                if (b.attackCooldown > 0) b.attackCooldown -= dt;

                if (!player.dead) { if (b.type === 'raptor' && dist < 20) b.state = 'chase'; else if (b.type === 'trike' && dist < 10) b.state = 'chase'; }
                
                if (b.state === 'chase' && playerDino.position.y < WATER_LEVEL + 0.5) {
                    b.state = 'patrol'; 
                    let landPoint; let tries = 0;
                    do {
                       landPoint = findPlainsSpawn();
                       landPoint.x += (Math.random()-0.5)*50;
                       landPoint.z += (Math.random()-0.5)*50;
                       tries++;
                    } while (getH(landPoint.x, landPoint.z) < WATER_LEVEL + 1.0 && tries < 10);
                    b.target.copy(landPoint);
                } 

                if (b.state === 'chase' && dist > 35) { b.state = 'patrol'; pickBotTarget(b); }
                if (b.state === 'patrol') {
                    b.stuck += dt; if(b.stuck > 10 || b.mesh.position.distanceTo(b.target) < 3) pickBotTarget(b);
                    moveBot(b, b.target, 0.055, dt); animBot(b, 'walk');
                } else if (b.state === 'chase') {
                    const attackRange = CONFIG[b.type].attackRange || 3.5;
                    if (dist > attackRange) { 
                        moveBot(b, playerDino.position, 0.1, dt); 
                        animBot(b, 'run'); 
                    } else {
                        b.mesh.lookAt(playerDino.position.x, b.mesh.position.y, playerDino.position.z); 
                        
                        // Use BOT cooldown specifically
                        if(b.acts.bite && b.attackCooldown <= 0) {
                            b.attackCooldown = CONFIG[b.type].attackCooldown; 
                            b.acts.bite.reset().setEffectiveWeight(1).play();
                            
                            if(dist < 30 && CONFIG[b.type].sndBite) {
                                const audio = new Audio(CONFIG[b.type].sndBite);
                                audio.volume = Math.max(0, 1 - dist/30);
                                audio.play().catch(e=>{});
                            }

                            setTimeout(() => { 
                                if(!b.dead && b.mesh.position.distanceTo(playerDino.position) < attackRange + 1.0) {
                                    takePlayerDamage(b.damage); 
                                }
                            }, 500); 
                        } else {
                            animBot(b, 'idle');
                        }
                    }
                }
                b.mesh.position.y = getH(b.mesh.position.x, b.mesh.position.z); b.mixer.update(dt);
            });
        }

        function moveBot(bot, target, speed, dt) {
            const dir = new THREE.Vector3().subVectors(target, bot.mesh.position).normalize();
            bot.mesh.position.add(dir.multiplyScalar(speed * 40 * dt)); bot.mesh.lookAt(target.x, bot.mesh.position.y, target.z);
        }
        function animBot(bot, anim) {
            const lerp = (a, w) => { if(a) a.setEffectiveWeight(THREE.MathUtils.lerp(a.getEffectiveWeight(), w, 0.1)); };
            lerp(bot.acts.idle, anim==='idle'?1:0); lerp(bot.acts.walk, anim==='walk'?1:0); lerp(bot.acts.run, anim==='run'?1:0);
        }

        function updatePlayer(dt) {
            if (!playerDino || player.dead) return;
            const canMove = !player.resting && player.actionState === 'idle';
            if (canMove && (input.x !== 0 || input.y !== 0)) {
                const ang = Math.atan2(input.x, input.y) + camAngle;
                const q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), ang);
                playerDino.quaternion.slerp(q, 0.05);
                const spd = player.running ? activeConfig.speedRun : activeConfig.speedWalk;
                playerDino.translateZ(spd); player.moving = true;
            } else { player.moving = false; }
            
            // LIFTING PLAYER UP
            playerDino.position.y = getH(playerDino.position.x, playerDino.position.z) + (activeConfig.modelOffsetY || 0);
            
            const lerp = (a, w) => { if(a) a.setEffectiveWeight(THREE.MathUtils.lerp(a.getEffectiveWeight(), w, 8*dt)); };
            let target = 'idle'; if(player.resting) target='rest'; else if(player.moving && player.actionState==='idle') target = player.running ? 'run' : 'walk';
            lerp(actions.idle, target==='idle' && player.actionState==='idle'?1:0); lerp(actions.walk, target==='walk' && player.actionState==='idle'?1:0); lerp(actions.run, target==='run' && player.actionState==='idle'?1:0); lerp(actions.rest, target==='rest'?1:0);
            gameMixer.update(dt);
            const cd = activeConfig.camDist || 14, ch = activeConfig.camHeight || 1.2;
            const cx = playerDino.position.x + Math.sin(camAngle)*cd*Math.cos(camHeight), cz = playerDino.position.z + Math.cos(camAngle)*cd*Math.cos(camHeight), cy = playerDino.position.y + cd*Math.sin(camHeight);
            gameCamera.position.lerp(new THREE.Vector3(cx,cy,cz), 0.15); gameCamera.lookAt(playerDino.position.x, playerDino.position.y + ch, playerDino.position.z);
            
            // STAMINA DRAIN LOGIC
            const drainRate = activeConfig.staminaDrain || 8;
            if(player.running && player.moving) player.stamina -= drainRate*dt; 
            else if(player.resting) {
                player.stamina += 10*dt; 
                player.hp += 5 * dt; 
                if(player.hp > player.maxHp) player.hp = player.maxHp;
            }
            else player.stamina += 3*dt;

            player.stamina = Math.max(0, Math.min(100, player.stamina)); if(player.stamina<=0) { player.running=false; document.getElementById('btnRun').classList.remove('active-mode'); }
            player.hunger -= 0.3 * dt; player.thirst -= 0.5 * dt; if(player.hunger<0 || player.thirst<0) player.hp -= 1*dt;
            if(player.hp<=0) { player.dead=true; alert("DIED"); exitToMenu(); }
            
            document.getElementById('player-hp-fill').style.width = (player.hp / player.maxHp * 100) + '%';
            document.getElementById('fill-hunger').style.height = player.hunger+'%'; document.getElementById('fill-thirst').style.height = player.thirst+'%'; document.getElementById('fill-stamina').style.height = player.stamina+'%';
            checkInteractions();
        }

        function checkInteractions() {
            if(!playerDino || player.actionState !== 'idle') return;
            let canEat = false;
            if (activeConfig.diet === 'herbivore') { for(let p of treePositions) if(playerDino.position.distanceTo(p) < 8) { canEat = true; break; } } else { for(let b of bots) if(b.dead && playerDino.position.distanceTo(b.mesh.position) < 5) { canEat = true; break; } }
            
            const y = playerDino.position.y; 
            let canDrink = false;
            // STRICTER DRINKING CHECK (ONLY IN WATER)
            if (y < WATER_LEVEL + 0.2 && y > WATER_LEVEL - 4.0) {
                canDrink = true;
            }
            
            document.getElementById('btnEatAction').style.display = canEat ? 'flex' : 'none'; 
            document.getElementById('btnDrinkAction').style.display = canDrink ? 'flex' : 'none';
        }

        function takeBotDamage(amt, rangeOverride) {
            const range = rangeOverride || 4.0;
            bots.forEach(b => {
                if(!b.dead && playerDino.position.distanceTo(b.mesh.position) < range) {
                    b.hp -= amt; showDmg(amt, b.mesh.position, '#fff');
                    b.mesh.traverse(o=>{if(o.isMesh){o.material.emissive=new THREE.Color(0xff0000); o.material.emissiveIntensity=0.5; setTimeout(()=>o.material.emissiveIntensity=0,100);}});
                    if(b.hp <= 0) { 
                        b.dead = true; b.deathTimer = 0; b.mesh.rotation.z = Math.PI/2; b.mixer.stopAllAction();
                        let reward = 50; if(b.type==='trike') reward = 100;
                        playerData.coins += reward;
                        saveData();
                        showDmg(`+${reward} üí∞`, b.mesh.position, '#ffeb3b');
                    }
                }
            });
        }
        function takePlayerDamage(amt) { player.hp -= amt; showDmg("-" + amt, playerDino.position, '#f00'); if(player.hp<=0) { player.dead=true; alert("YOU DIED"); exitToMenu(); } }
        function showDmg(val, pos, col) {
            const d = document.createElement('div'); d.className='damage-text'; d.style.color=col; d.innerText=val; document.body.appendChild(d);
            const v = pos.clone().project(gameCamera); d.style.left = (v.x*.5+.5)*window.innerWidth+'px'; d.style.top = (-(v.y*.5)+.5)*window.innerHeight+'px'; setTimeout(()=>d.remove(), 1000);
        }

        function performLockedAction(type, duration, callback) {
            if (player.actionState !== 'idle' || player.resting) return;
            player.actionState = type; player.moving = false; let clip = null;
            if (type === 'eat') clip = actions.eat || actions.bite; if (type === 'drink') clip = actions.drink;
            if (clip) clip.reset().setEffectiveWeight(1).fadeIn(0.1).play();
            setTimeout(() => { if (clip) clip.fadeOut(0.5); player.actionState = 'idle'; if (callback) callback(); }, duration);
        }

        function setupControls() {
            document.getElementById('btnSettings').addEventListener('touchstart', (e)=>{ e.preventDefault(); e.stopPropagation(); const p = document.getElementById('settingsPanel'); p.style.display = p.style.display==='block'?'none':'block'; });
            const bindSet = (id, cb) => { document.getElementById(id).addEventListener('touchstart', (e)=>{ e.stopPropagation(); cb(); }); };
            bindSet('btnVegLow', ()=>setVegetation('low', document.getElementById('btnVegLow'))); bindSet('btnVegMid', ()=>setVegetation('mid', document.getElementById('btnVegMid'))); bindSet('btnResLow', ()=>setResolution(0.2, document.getElementById('btnResLow'))); bindSet('btnResMid', ()=>setResolution(0.55, document.getElementById('btnResMid'))); bindSet('btnResHigh', ()=>setResolution(1.0, document.getElementById('btnResHigh')));
            const zl = document.getElementById('zone-left'), jb = document.getElementById('joyBase'), js = document.getElementById('joyStick');
            let jId = null, startX, startY;
            zl.addEventListener('touchstart', e=>{ if(player.actionState!=='idle') return; e.preventDefault(); const t=e.changedTouches[0]; jId=t.identifier; startX=t.clientX; startY=t.clientY; jb.style.display='block'; jb.style.left=(startX-35)+'px'; jb.style.top=(startY-35)+'px'; });
            zl.addEventListener('touchmove', e=>{ e.preventDefault(); if(player.actionState!=='idle'){input.x=0;return;} for(let t of e.changedTouches) if(t.identifier===jId) { let dx=t.clientX-startX, dy=t.clientY-startY; js.style.transform = `translate(${Math.cos(Math.atan2(dy,dx))*Math.min(35,Math.hypot(dx,dy))}px, ${Math.sin(Math.atan2(dy,dx))*Math.min(35,Math.hypot(dx,dy))}px)`; input.x=Math.cos(Math.atan2(dy,dx)); input.y=Math.sin(Math.atan2(dy,dx)); } });
            zl.addEventListener('touchend', ()=>{ jId=null; jb.style.display='none'; input.x=0; input.y=0; });
            let cId=null, lx, ly;
            document.getElementById('zone-right').addEventListener('touchstart', e=>{cId=e.changedTouches[0].identifier; lx=e.changedTouches[0].clientX; ly=e.changedTouches[0].clientY;});
            document.getElementById('zone-right').addEventListener('touchmove', e=>{ for(let t of e.changedTouches) if(t.identifier===cId) { camAngle -= (t.clientX-lx)*0.005; camHeight += (t.clientY-ly)*0.005; camHeight = Math.max(0.1, Math.min(1.5, camHeight)); lx=t.clientX; ly=t.clientY; } });
            const setupBtn = (id, cb) => { document.getElementById(id).addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); cb(e); }); };
            setupBtn('btnRest', ()=>{ if(player.actionState==='idle') { player.resting=!player.resting; player.running=false; } });
            setupBtn('btnRun', ()=>{ if(!player.resting && player.stamina>0) player.running=!player.running; });
            
            const doAct = (name, anim, block) => {
                if(player.resting) return; if(block && player.actionState!=='idle') return; if (name === 'bite' && player.cdBite) return; if (name === 'roar' && player.cdRoar) return;
                
                if(block && name !== 'roar' && name !== 'bite') player.actionState = name; 
                
                let duration = 1000;
                if(anim) { 
                    duration = (anim.getClip().duration / anim.timeScale) * 1000; 
                    anim.reset().setEffectiveWeight(1).fadeIn(0.1).play(); 
                    setTimeout(()=>{ anim.fadeOut(0.3); if(block && name !== 'roar' && name !== 'bite') player.actionState='idle'; }, duration - 300); 
                }
                
                if(name==='bite') { 
                    const range = (activeConfig.attackRange || 4); 
                    takeBotDamage(activeConfig.damage, range); 
                    if(activeConfig.audioBite) { activeConfig.audioBite.currentTime = 0; activeConfig.audioBite.play().catch(e=>{}); }
                    player.cdBite = true; const btn = document.getElementById('btnBite'); btn.classList.add('cooldown'); 
                    const cdTime = activeConfig.playerAttackCooldown || activeConfig.attackCooldown;
                    setTimeout(() => { player.cdBite = false; btn.classList.remove('cooldown'); }, cdTime * 1000); 
                }
                if(name==='roar') { 
                    if(activeConfig.audioRoar) { activeConfig.audioRoar.currentTime = 0; activeConfig.audioRoar.play().catch(e=>{}); }
                    player.cdRoar = true; const btn = document.getElementById('btnRoar'); btn.classList.add('cooldown'); setTimeout(() => { player.cdRoar = false; btn.classList.remove('cooldown'); }, 2500); 
                }
            };
            setupBtn('btnBite', ()=>doAct('bite', actions.bite, false)); 
            setupBtn('btnRoar', ()=>doAct('roar', actions.roar, false)); 
            setupBtn('btnEatAction', ()=>{ performLockedAction('eat', 4000, () => { player.hunger=Math.min(100, player.hunger+30); }); });
            setupBtn('btnDrinkAction', ()=>{ performLockedAction('drink', 4000, () => { player.thirst=Math.min(100, player.thirst+30); }); });
        }
        function animate() {
            requestAnimationFrame(animate); const dt = clock.getDelta();
            if(waterMesh) { waterMesh.material.map.offset.x += 0.0002; waterMesh.material.map.offset.y += 0.0002; }
            if (isGameRunning) { updatePlayer(dt); updateGameBots(dt); renderer.render(gameScene, gameCamera); } 
            else if (menuScene) {
                if(menuMixer) menuMixer.update(dt);
                if(menuScene.userData.dino) { menuScene.userData.dino.rotation.y += 0.005; menuScene.userData.dino.position.x = THREE.MathUtils.lerp(menuScene.userData.dino.position.x, menuDinoTargetX, 0.1); }
                renderer.render(menuScene, menuCamera);
            }
        }
        function onResize() { const w = window.innerWidth, h = window.innerHeight; renderer.setSize(w, h); if(menuCamera) { menuCamera.aspect = w/h; menuCamera.updateProjectionMatrix(); } if(gameCamera) { gameCamera.aspect = w/h; gameCamera.updateProjectionMatrix(); } }
        window.addEventListener('resize', onResize);
    </script>
</body>
</html>
